# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01c_classification.modelling.backbones.ipynb (unless otherwise specified).

__all__ = ['has_pool_type', 'create_body', 'TimmCnnBody', 'TorchvisionCnnBody', 'CNN_BODY_REGISTRY', 'create_cnn_body']

# Cell
from typing import *
import importlib

import timm
import torch
from torch import nn

import re
from omegaconf import DictConfig
from fastcore.all import use_kwargs_dict

from torchvision import models

from ...core.layers import *
from ...core import Registry, ACTIVATION_REGISTERY

# Cell
def _is_pool_type(l):
    return re.search(r"Pool[123]d$", l.__class__.__name__)

# Cell
def has_pool_type(m):
    "Return `True` if `m` is a pooling layer or has one in its children"
    if _is_pool_type(m):
        return True
    for l in m.children():
        if has_pool_type(l):
            return True
    return False

# Cell
def create_body(model: nn.Module, cut: Optional[Union[int, Callable]] = None):
    "Cut off the body of a `model` as determined by `cut`"
    if cut is None:
        ll = list(enumerate(model.children()))
        cut = next(i for i, o in reversed(ll) if has_pool_type(o))
    if isinstance(cut, int):
        return nn.Sequential(*list(model.children())[:cut])
    elif callable(cut):
        return cut(model)
    else:
        raise NamedError("cut must be either integer or a function")

# Cell
class TimmCnnBody(nn.Module):
    "default `nn.Module` to create a body for vision applications from `timm`"

    @use_kwargs_dict(keep=True, pretrained=False, num_classes=0, global_pool="")
    def __init__(self, model_name: str, cut=None, act_layer: str = None, **kwargs):
        super(TimmCnnBody, self).__init__()
        # for different activation funtions
        # if act_layer is None then the default activations func will be used
        if act_layer is not None:
            act_layer = ACTIVATION_REGISTERY.get(act_layer)

        net = timm.create_model(model_name, act_layer=act_layer, **kwargs)

        # prepare body
        self.net = create_body(net, cut)

    def forward(self, xb):
        return self.net(xb)

    @classmethod
    def from_config(cls, config: DictConfig):
        "create from a `Omegaconf/ Hydra` config"
        return cls(**config)

# Cell
def _get_first_layer(m):
    "Access first layer of a model"
    c, p, n = m, None, None  # child, parent, name
    for n in next(m.named_parameters())[0].split(".")[:-1]:
        p, c = c, getattr(c, n)
    return c, p, n

# Cell
def _update_first_layer(model, n_in):
    "Change first layer based on number of input channels used for torchvisions.models"
    if n_in == 3:
        return
    first_layer, parent, name = _get_first_layer(model)
    assert isinstance(
        first_layer, nn.Conv2d
    ), f"Change of input channels only supported with Conv2d, found {first_layer.__class__.__name__}"
    assert (
        getattr(first_layer, "in_channels") == 3
    ), f'Unexpected number of input channels, found {getattr(first_layer, "in_channels")} while expecting 3'
    params = {
        attr: getattr(first_layer, attr)
        for attr in "out_channels kernel_size stride padding dilation groups padding_mode".split()
    }
    params["bias"] = getattr(first_layer, "bias") is not None
    params["in_channels"] = n_in
    new_layer = nn.Conv2d(**params)
    setattr(parent, name, new_layer)

# Cell
class TorchvisionCnnBody(nn.Module):
    "default `nn.Module` to create a body for vision applications from `torchvision.models`"

    def __init__(
        self, model_name: str, in_chans: int = 3, pretrained: bool = True, cut=None
    ):
        super(TorchvisionCnnBody, self).__init__()

        module = importlib.import_module(f"torchvision.models")
        model = getattr(module, model_name)(pretrained=pretrained)

        # update the channnels of the first layer
        _update_first_layer(model, n_in=in_chans)
        self.net = create_body(model, cut)

    def forward(self, xb):
        return self.net(xb)

    @classmethod
    def from_config(cls, config: DictConfig):
        "create from a `Omegaconf/ Hydra` config"
        return cls(**config)

# Cell
CNN_BODY_REGISTRY = Registry("CNN_Body")
CNN_BODY_REGISTRY.register(TimmCnnBody)
CNN_BODY_REGISTRY.register(TorchvisionCnnBody)

# Cell
def create_cnn_body(cfg: DictConfig) -> nn.Module:
    "instante an obj from ModelBody registery using lightning_cv config"
    body = CNN_BODY_REGISTRY.get(cfg.MODEL.BACKBONE.NAME)
    body = body.from_config(cfg.MODEL.BACKBONE.ARGUMENTS)
    return body