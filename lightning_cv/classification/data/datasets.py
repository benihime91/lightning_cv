# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01b_classification.data.datasets.ipynb (unless otherwise specified).

__all__ = ['logger', 'BaseClassificationDataset', 'ImageFolderDataset', 'ImageCsvDataset']

# Cell
import os
import pandas as pd
from typing import *
from pathlib import Path
from abc import ABC
from fastcore.all import store_attr, ifnone, delegates

import torch
from torch.utils.data import Dataset
from torchvision.datasets.folder import make_dataset

from ...core.common import default_logger
from ...core.data_utils import IMG_EXTENSIONS, Loaders
from .transforms import ImageClassificationTransforms

logger = default_logger()

# Cell
#hide
class BaseClassificationDataset(Dataset):
    "Base class for ImageClassification Dataset"
    _transforms = None

    @property
    def transforms(self):
        return self._transforms

    @transforms.setter
    def transforms(self, x: ImageClassificationTransforms):
        self._transforms = x

    def __getitem__(self, x):
        raise NotImplementedError

    def __len__(self, x):
        raise NotImplementedError

# Cell
class ImageFolderDataset(BaseClassificationDataset):
    "Create `Dataset` instance from `source` using `transforms`"

    def __init__(self, source: Union[str, Path], transforms: ImageClassificationTransforms, classes: Dict = None,
                 loader: str = "pil_loader", test : bool = False):

        store_attr("source, test")
        self.loader = Loaders.get(loader)
        self._transforms = transforms

        if not self.test:
            self.classes = ifnone(classes, self._find_classes(self.source))
            samples = make_dataset(self.source, self.classes, IMG_EXTENSIONS, None)
            self.images  = [s[0] for s in samples]
            self.targets = [s[1] for s in samples]
            logger.info(f"Found {len(self.images)} files belonging to {len(set(self.targets))} classes.")
        if self.test:
            samples = self.make_test(source)
            self.images = samples
            logger.info(f"Found {len(self.images)} files.")

    def _find_classes(self, dir: str) -> Tuple[List[str], Dict[str, int]]:
        "Finds the class folders in the dataset"
        classes = [d.name for d in os.scandir(dir) if d.is_dir()]
        classes.sort()
        class_to_idx = {cls_name: i for i, cls_name in enumerate(classes)}
        return class_to_idx

    @staticmethod
    def has_file_allowed_extension(filename: str, extensions: Tuple[str, ...]) -> bool:
        """
        Checks if a file is an allowed extension.
        Args:
            filename (string): path to a file
            extensions (tuple of strings): extensions to consider (lowercase)
        Returns:
            bool: True if the filename ends with one of given extensions

        From : https://github.com/pytorch/vision/blob/master/torchvision/datasets/folder.py
        """
        return filename.lower().endswith(extensions)

    @staticmethod
    def is_valid_file(x: str) -> bool:
        return ImageFolderDataset.has_file_allowed_extension(x, cast(Tuple[str, ...], IMG_EXTENSIONS))

    @staticmethod
    def make_test(root: str):
        instances = []
        is_valid_file = cast(Callable[[str], bool], ImageFolderDataset.is_valid_file)
        for fname in os.listdir(root):
            path = os.path.join(root, fname)
            if is_valid_file(path):
                instances.append(path)
        return instances

    def __len__(self):
        return len(self.images)

    def __getitem__(self, index):
        image  = self.images[index]
        image  = self.loader(image)
        aug_im = self._transforms(image)
        if self.test:
            return aug_im
        else:
            label  = self.targets[index]
            return aug_im, torch.tensor(label, dtype=torch.long)

# Cell
class ImageCsvDataset(BaseClassificationDataset):
    "Create `Dataset` instance from `csv` using `transforms`, `image_col` and `label_col`"

    @delegates(pd.read_csv)
    def __init__(self, csv: str, image_col: str, transforms: ImageClassificationTransforms, label_col: Optional[str] = None,
                 loader: str = "pil_loader", test: bool = False, **kwargs):

        store_attr("label_col, image_col, test")

        self.df = pd.read_csv(csv, **kwargs)
        self.loader = Loaders.get(loader)
        self._transforms = transforms

    def __len__(self):
        return len(self.df)

    def __getitem__(self, index):
        image  = self.df[self.image_col][index]
        image  = self.loader(image)
        aug_im = self._transforms(image)

        if self.test:
            return aug_im
        if not self.test:
            label = self.df[self.label_col][index]
            label = torch.tensor(label, dtype=torch.long)
            return aug_im, label