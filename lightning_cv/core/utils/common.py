# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00a_core.utils.common.ipynb (unless otherwise specified).

__all__ = ['default_logger', 'FORMAT', 'ROOT_NAME', 'ABBREV_NAME', 'imshow_tensor', 'subplots', 'show_image',
           'show_titled_image', 'show_images', 'generate_random_id', 'set_seed', 'params', 'trainable_params',
           'maybe_convert_to_onehot']

# Cell
import sys
import math
import uuid
import loguru
import random
import logging
import matplotlib.pyplot as plt

from fvcore.common.registry import Registry

from fastcore.all import delegates, hasattrs, ifnone

import torch
import numpy as np
from torchvision.utils import make_grid

# Cell
FORMAT = "<lvl>{level}</lvl> <green>[{time:MM/DD HH:mm:ss} {name}]</green>: {message}"
ROOT_NAME = "lightning_cv"
ABBREV_NAME = "lcv"


@delegates(loguru.logger.add)
def default_logger(
    sink=sys.stdout, level=logging.INFO, format=FORMAT, colorize=True, **kwargs
):
    "default logger for the Library"
    logger = loguru.logger
    logger.remove()
    logger.add(sink, level=level, format=format, colorize=colorize, **kwargs)
    logger = logger.patch(
        lambda record: record.update(
            name=record["name"].replace(ROOT_NAME, ABBREV_NAME)
        )
    )
    return logger

# Cell
@delegates(make_grid)
def imshow_tensor(inp, title=None, **kwargs):
    """Imshow for Tensor and optionally add a `title`"""
    grid = make_grid(inp, **kwargs)
    grid = grid.permute(1, 2, 0).data.numpy()
    plt.imshow(grid)

    if title is not None:
        plt.title(title)

    plt.pause(0.001)

# Cell
@delegates(plt.subplots, keep=True)
def subplots(nrows=1, ncols=1, figsize=None, imsize=3, suptitle=None, **kwargs):
    if figsize is None:
        h = nrows * imsize if suptitle is None or imsize > 2 else nrows * imsize + 0.6
        figsize = (ncols * imsize, h)
    fig, ax = plt.subplots(nrows, ncols, figsize=figsize, **kwargs)
    if suptitle is not None:
        fig.suptitle(suptitle)
    if nrows * ncols == 1:
        ax = np.array([ax])
    return fig, ax

# Cell
def _fig_bounds(x):
    r = x // 32
    return min(5, max(1, r))

# Cell
@delegates(plt.Axes.imshow, keep=True, but=["shape", "imlim"])
def show_image(im, ax=None, figsize=None, title=None, ctx=None, **kwargs):
    "Show a PIL or PyTorch image on `ax`."
    # Handle pytorch axis order
    if hasattrs(im, ("data", "cpu", "permute")):
        im = im.data.cpu()
        if im.shape[0] < 5:
            im = im.permute(1, 2, 0)
    elif not isinstance(im, np.ndarray):
        im = np.array(im)
    # Handle 1-channel images
    if im.shape[-1] == 1:
        im = im[..., 0]

    ax = ifnone(ax, ctx)
    if figsize is None:
        figsize = (_fig_bounds(im.shape[0]), _fig_bounds(im.shape[1]))
    if ax is None:
        _, ax = plt.subplots(figsize=figsize)
    ax.imshow(im, **kwargs)
    if title is not None:
        ax.set_title(title)
    ax.axis("off")
    return ax

# Cell
@delegates(show_image, keep=True)
def show_titled_image(o, **kwargs):
    "Call `show_image` destructuring `o` to `(img,title)`"
    show_image(o[0], title=str(o[1]), **kwargs)

# Cell
@delegates(subplots)
def show_images(ims, nrows=1, ncols=None, titles=None, **kwargs):
    "Show all images `ims` as subplots with `rows` using `titles`."
    if ncols is None:
        ncols = int(math.ceil(len(ims) / nrows))
    if titles is None:
        titles = [None] * len(ims)
    axs = subplots(nrows, ncols, **kwargs)[1].flat
    for im, t, ax in zip(ims, titles, axs):
        show_image(im, ax=ax, title=t)

# Cell
def generate_random_id() -> str:
    "generates a random id"
    idx = uuid.uuid1()
    idx = str(idx).split("-")[0]
    return idx

# Cell
def set_seed(s, reproducible=False):
    "Set random seed for `random`, `torch`, and `numpy` (where available)"
    try:
        torch.manual_seed(s)
    except NameError:
        pass
    try:
        torch.cuda.manual_seed_all(s)
    except NameError:
        pass
    try:
        np.random.seed(s % (2 ** 32 - 1))
    except NameError:
        pass
    random.seed(s)
    if reproducible:
        torch.backends.cudnn.deterministic = True
        torch.backends.cudnn.benchmark = False

# Cell
def params(m):
    "Return all parameters of `m`"
    return [p for p in m.parameters()]

# Cell
def trainable_params(m):
    "Return all trainable parameters of `m`"
    return [p for p in m.parameters() if p.requires_grad]

# Cell
@torch.no_grad()
def maybe_convert_to_onehot(activations: torch.Tensor, labels: torch.Tensor):
    "converts `labels` to onehot Tensors"
    if len(labels.shape) < len(activations.shape):
        onehot = torch.zeros_like(activations)
        onehot.scatter_(1, labels[..., None], 1)
        labels = onehot
    return labels

# Cell
Registry.__doc__ = "The registry that provides `name` -> `object mapping`, to support third-party users' custom modules."